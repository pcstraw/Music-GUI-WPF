[
  {
    "Id": "1106936",
    "ThreadId": "462037",
    "Html": "Last night I was looking into drag&amp;drop functionality because I needed to drag items from the list to another control.  If I get it correctly , now the controller pass drag event to TreeItemEx and from there the only option is to bind it to a function in the item itself. It's not possible to bind the event to the ViewModel (or to the codebehind) since a reference to TreeItemEx/item is not passed to the method. \r<br />\n<br />\nThis is very inconvenient. \r<br />\nOne reason is that we don't always have source access to the items we want to add to the list. Even if we do, those objects might also be used in other scenarios as well. I don't feel comfortable placing UI login into the Model. That's what the ViewModel is for.\r<br />\n<br />\nAlso, most of the time those items would be just lightweight items that don't know much about their context. They most certainly default to a simple {return this;} inside OnDrag().\r<br />\nImplementing CanDrag() is also complicated. The viewModel must constantly update the AllowDrag state on all items, or each object must keep a reference to the ViewModel and query it about the current state of the application.\r<br />\n<br />\nIt would be much more useful for the TreeViewEx Control to dispatch drag events/Commands to the ViewModel. That would allow a wider range of scenarios and be inline with the MVVM paradigm. <br />\n",
    "PostedDate": "2013-10-13T15:31:38.277-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1107027",
    "ThreadId": "462037",
    "Html": "So the idea is to have another mechanism that targets some common view model? \r<br />\n<br />\nI could imagine to implement all 7 delegates (CanInsert, Drag, ...) on TreeViewEx, with a reference to the node. So the dragNdrop controller would check the nodes first and the treeview as second. This is because I think each node to provide its own status, is the most common use case.<br />\n",
    "PostedDate": "2013-10-14T01:03:55.727-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1107606",
    "ThreadId": "462037",
    "Html": "That would be great. \r<br />\n<br />\nSince the delegate would have access to the node reference it could be easy for the developer to just query the Node for it's status. \r<br />\nOf course this would add some more code so I am ok with providing two options.\r<br />\n<br />\nThere are a lot of senarios as well where you can't store the CanDrag/etc on the node. \r<br />\n Imagine for example a client that retrieves a list of items from a web service. VS will automatically generate the Classes that represent those data. \r<br />\nYou 'd like to bind those data into TreeViewEx and then drag one item into another control to initiate a process.\r<br />\n<br />\n Another example, imagine a layout editor for something like XAML, where you want to visualize the content in a treeview. You either don't have the source or don't want to pollute the layout elements with the Editor's UI logic.<br />\n",
    "PostedDate": "2013-10-15T05:45:38.093-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1107706",
    "ThreadId": "462037",
    "Html": "In case someone want to detach the item, It would be nice if the StartDrag &amp; DoDrag  pass the parent TreeViewExItem as the sender of the event.\r<br />\n...or the parent item. \r<br />\n<br />\nTraversing the tree for this reason wont work, not only its slow but there is no guaranty that an item isn't bind twice at different places.<br />\n",
    "PostedDate": "2013-10-15T07:41:53.83-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1108214",
    "ThreadId": "462037",
    "Html": "I was also trying to clean up my code and I wanted to propose a solution that may satisfy everyone.\r<br />\nI would prefer to use Command over event because it's more MVVM compilant, and they already have the CanExecute/Execute mecanism.\r<br />\nSo, we could have:<br />\n<ul>\n<li>in TreeViewExItem, three bindable commands : DragCommand, InsertCommand, DropCommand. We can use Tuple&lt;int, object&gt; as parameter for the InsertCommand. It is not perfect but at least its in mscorlib so no need for additional dependencies.</li>\n<li>CanInsert and CanInsertFormat should be replaced by the CanExecute method. Is there a problem to have a single &quot;check if I can&quot; method? - same for CanDrop/CanDropFormat. We can again use Tuple to concatenate arguments into a single object.</li>\n<li>TreeViewEx would also have these tree commands, with an additional parameter being the ViewModel of the targeted node. This allows to bind commands that are outside of the view model, to deport the work when we dont have access to the viewmodel source.</li>\n<li>\nSo the drag'n'drop controller would try to invoke commands in the items first, but if they are null, it would fallback on the commands of the TreeViewEx.<br />\n</li>\n</ul>\nIf this solution satisfies you, I can implement it very quicky. <br />\n",
    "PostedDate": "2013-10-16T04:06:21.03-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1108543",
    "ThreadId": "462037",
    "Html": "Personally I prefer events, they are strongly typed, but I guess Commands are the new standard when working with MVVM so I try to enforce them when I can so I don't get outdated. I think you get better support on VS/blend editors with commands.<br />\n\r<br />\nNow to your points:\r<br />\n<br />\n1) are you referring to DragContent dependencies? \r<br />\nOnce we get Drag/Insert/Drop on TreeViewEx/ViewModel level we don't have to worry about putting System.Windows.Controls.DragNDrop dependencies to our Model projects (in case your model is separate from your WPF/UI project).   DragContent carries some useful info for the operation and can get extended in the future. In case you want to drop items into multiple controls, IDataObject support multiple formats, so you can contstract a DragContent as well to enable dropping into TreeViewEx. \r<br />\nSo, I don't see much of a problem there. \r<br />\nAs I said above, it would be great if DragContent provide the additional info of the parent item in the hirierchy, so one could easily detach/move  items around. The samples so far only demonstrate Copy.\r<br />\n<br />\n2) Maybe slompf can enlighten us what's the typical use of CanDropFormat and if a CanDrop with access to DragContent can replace it.\r<br />\n<br />\n3) I really don't get this one. You bind commands to your ViewModel. You always have access to ViewModel source, its part of your project. It decouples your View from the Model and contains all the business logic. \r<br />\nHow can the targeted node have a different ViewModel? Perhaps its a different treevViewEx or the target is some other control, ok, so why do we need to pass a reference to it's own ViewModel? Perhaps you were talking about something else I I misanterstant, can you clarify? \r<br />\n<br />\n<br />\nThe final word of how things get done comes to slompf, he done a terrific job so far and has a better understanding of the overall design and where it's going.\r<br />\nFor example, I see a problem of how a DragCommand would return the desired object since commands return void. (in the samples onDrag returns 'this' but perhaps one would like to return 'this.Name' or something else...). The command parameter could be a struct where you supposed to cast (that's why I prefer events) and fill it up, or initiate the Drag yourself (not very good, a lot could go wrong).<br />\n",
    "PostedDate": "2013-10-16T16:16:45.57-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1108707",
    "ThreadId": "462037",
    "Html": "Yes, the problem of events is especially that they are strongly typed (and not easily bindable).\r<br />\n<br />\n1) You're not supposed to reference types from your view (ie. TreeViewEx) in the ViewModel. For example in my project I have a single ViewModel which is shared between several views, and one of them is in an assembly that can't reference TreeViewEx. I propose to pass the members of the DragContent object as a Tuple. This is not ideal, but at least it does not require any additional dependency. I'm open to other solutions to avoid using an object that would require a reference to the TreeViewEx assembly, such as maybe a property container / key&gt;value collection.\r<br />\nReferencing the parent would not be a problem, it could just be an additional item to the container used as argument to the commands. However I would recommend that each ViewModel item references its parent itself, but sometimes it's just not possible :)\r<br />\n<br />\n3) I will explain my idea better with some code snippets, but I just want to answer your last point before (the return value of onDrag). I didn't think of that point but as you said, it could be easy to put the result in a field of the tuple/container of the command. This requires a cast, sure, but that's how many things in the MVVM design already works (bindings, dependency properties, commands...). Not that I like it, but it helps to detach the different layers of the design. As long as the struct is a container provided by mscorlib or any standard assembly, it would be good for me.\r<br />\n<br />\nSo let me just write some snippets of my idea, it could be easier to understand (it's not particularly complicated at all)\r<br />\nI meant to add the following dependency properties in TreeViewExItem:<br />\n<pre><code>DependencyProperty DragCommandProperty = DependencyProperty.Register(&quot;DragCommand&quot;, typeof(ICommand), typeof(TreeViewExItem));\nDependencyProperty DropCommandProperty = DependencyProperty.Register(&quot;DropCommand&quot;, typeof(ICommand), typeof(TreeViewExItem));\nDependencyProperty InsertCommandProperty = DependencyProperty.Register(&quot;InsertCommand&quot;, typeof(ICommand), typeof(TreeViewExItem));</code></pre>\n\nThe DragNDropController class can then invoke these commands. For example, CanDrop would do (in a simplified way):<br />\n<pre><code>if (item.DropCommand != null)\n{\n    if (item.DropCommand.CanExecute(Tuple.Create&lt;string, object&gt;(format, data))\n        return true;\n}\nreturn false;</code></pre>\n\nAnd OnDrop would do:<br />\n<pre><code>item.DropCommand.Execute(Tuple.Create&lt;string, object&gt;(format, data))</code></pre>\n\nThen you can very easily create these commands in your ViewModel and handle them in your item style:<br />\n<pre><code>&lt;TreeViewEx.ItemContainerStyle&gt;\n  &lt;Style BasedOn=&quot;...&quot;&gt;\n    &lt;Setter Property=&quot;DropCommand&quot; Value=&quot;{Binding MyDropCommand}/&gt;\n  &lt;/Style&gt;\n&lt;/TreeViewEx.ItemContainerStyle&gt;</code></pre>\n\nBut as you say, sometimes you just can't afford to modify the item's viewmodel. So I proposed a fallback method to handle drag'n'drop commands, directly in the TreeViewEx itself and in the treeview data context (viewmodel), which should be the container of the item view models. This is purely additional and for the convenience of the user only:<br />\n<pre><code>&lt;TreeViewEx DropCommand=&quot;{Binding MyDropCommand}&quot;/&gt;</code></pre>\n\nThen the DragNDropController could fallback this way, passing the item viewmodel to a more global command:<br />\n<pre><code>if (item.DropCommand != null)\n    ...\nelse if (treeview.DropCommand != null)\n{\n    if (treeview.DropCommand.CanExecute(Tuple.Create&lt;string, object, object&gt;(format, data, item.DataContext))\n        return true;\n}</code></pre>\n\n",
    "PostedDate": "2013-10-17T04:01:32-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1110868",
    "ThreadId": "462037",
    "Html": "By the way, if slompf decides to do a event-based system it's not a problem at all, since I can still make my own Behavior to achieve what I want to do. So it's really up to you :)<br />\n",
    "PostedDate": "2013-10-22T21:11:34.663-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1111958",
    "ThreadId": "462037",
    "Html": "Ok, so eventually I've manged to work through your ideas. ;)\r<br />\n<br />\nI see it as common sense, that commands might be a better idea. Because:<br />\n<ul>\n<li>They are more easy to bind. The method I use at the moment needs an additional class, which has to be referenced from the treeviewex assembly. Mostly no problem, but maybe sometimes.</li>\n<li>It is the more convenient way, because everybody knows it.</li>\n<li>\nThe CanDrop and CanDropFormat function can be merged. The idea was: if the viewmodel cannot work with the data, why should I call GetData? But doing it does not call a very great overhead and it will simplify the interface.<br />\n</li>\n</ul>\nBut with the solution given by Benelitz, there are some points we should think of:<br />\n<ul>\n<li>Tuple is a .Net 4 class. At the moment does not need very much change to compile the project to .Net 3.5. Do we really want to abondon the people beeing bound to 3.5? But we could use some kind of Array or dictionary to provide more data.</li>\n<li>As found by nkast: OnDrag has an return value. That one would have to be put into an given array. Not very nice.</li>\n<li>\nWhat would be a good objects to add as array content to the command: IDataObject of .Net maybe, DragContent if applicatble, format, Node on global commands. What else?<br />\n</li>\n</ul>\nIn general I'd like to focus on fixing the current release (Again many thanks for the massive testing). So everything we decide will be a task for the next release. In order to preapare, we could branch.<br />\n",
    "PostedDate": "2013-10-25T00:12:08.797-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1112005",
    "ThreadId": "462037",
    "Html": "That would be great slompf!\r<br />\n<br />\nMeanhwile i started experimenting on passing Proxy classes instead of  the actuall items. In part because I knew that this would take some time but also to address other issues i am having.  So for now, I believe I can work with the current TreeViewEx.<br />\n",
    "PostedDate": "2013-10-25T02:21:15.22-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]